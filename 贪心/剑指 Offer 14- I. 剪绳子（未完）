1.动态规划：
/*首先使用动态规划解决问题，最重要的就是理解dp数组的含义。
此处的dp[i] 表示长度为i的绳子剪成m段后的最大乘积。初始化dp[2] = 1 表示如果一个绳子长度为2必然只能分成两段长度为1的绳子，两者的乘积为1。
然后尝试对绳子进行分割，如果只剪掉长度为1，对最后的乘积无任何增益，所以从长度为2开始剪，代码中的j就是表示尝试剪的长度。
剪下一段后，剩余部分可以剪也可以不剪。如果不剪则得到的长度乘积为 j * (i - j) 。如果剪得到的长度为j * dp[i - j]两者取最大值
不断修改剪的长度j （j范围为[2, i -1]）。从所有结果中找到最大值即为dp[i]的结果。
从而有状态转移方程dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))*/
class Solution {
public:
    int cuttingRope(int n) {   
        vector<int> dp(n+1,0);              //dp[i]表示i长度的绳子得到的最大值，因为数组开n+1个
        dp[2] = 1;                          //长度如果是二，根据题意，显然只能一分为二
        for (int i=3;i<=n;++i){             //计算顺序为从小到大依次计算
            // i-j >= 2
            for (int j=1;j<=i-2;++j){       //依次遍历之后的j确定最大值
                // 这里因为m>1，所以dp[2] = 1而不是2，dp[3]不能是dp[2] * 1，这样答案是1，错误.
                // 因此下面要添加Math.max(dp[i-j], i-j)。
                dp[i] = max(max(j*dp[i-j], j*(i-j)), dp[i]);
            }
        }
        return dp[n];
    }
};
